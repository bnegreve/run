=pod 
=head1 Runtime

Runtime - Program and run reproducible software experiments with the command line interface.  
    
=head1 SYNOPSIS

 runtime -p PARAMETER_NAME parameter_value_1 .. parameter_value_n
 [-p PARAMETER2_NAME parameter2_value_1 .. parameter2_value_n]
 [-s extract_metric_script1 [-s extract_metric_script2 ...]
 [-m max_memory_usage (% total)] [ -t timeout value] [ -d (dryrun) ]
 -u using_expression -- command_line_template
 
=head1 DESCRIPTION 

    
Runtime should be use to collect and pre-format various statistics
such as execution time or memory usage for large batches of program
executions (runs).  The collected statistics are stored as lines and
columns into ascii files according to a format specified by the user. 
These files are meant to by read by humans or plotted with tools such as
gnuplot.

Runs are specified through a command line templated with parameter
names (a.k.a. the command line template), and list of parameter
specifications which include for each parameter the name of the
parameter and a list of possible values. 

Given a command line template and a parameter list, Runtime produces a
list of command lines to be executed by substituting each parameter
name in the command line template by a one of its possible value.

By default, all the parameter values are combined to produce the
complete list of command line to execute but the using expression can
be used to control how the parameters values are combined together.

For each run at least the execution time and maximum memory usage
are recorded. More metrics can be added through extraction scripts.

Once all the command line have been produced by Runtime, they are
displayed and executed. The data collected during the execution as
well as the output produced by the command line are stored into output
files.

Finally a README file is created to record various meta data about the
experimental setting. This includes the exact Runtime command that have been used to
generate this particular experiment such that copying and pasting this command
line will run the same experiment again. Other informations such as
the host name and the date are also stored in the README file to
improve reproducibility.


=head1 EXAMPLE

=head2 Comparing compiler compilation times. 

Let's say we want to compare the compilation time of various C compilers (e.g. gcc, clang) on different source code (e.g. quicksort.c, fibo.c). 

     runtime -p COMPILER gcc clang -p TEST_PROGRAM quicksort.c fibo.c -p OPTIMIZATION_LEVEL O1 O2 O3 Os -u TEST_PROGRAMfxCOMPILERcxOPTIMIZATION_LEVELl -- COMPILER -OPTIMIZATION_LEVEL TEST_PROGRAM

This declares three parameters called COMPILER TEST_PROGRAM and OPTIMIZATION_LEVEL. 
Each parameters takes values in the list following the parameter name, for example COMPILER can take two values, either 'gcc' or 'clang'. 

Running the specified command will build and run the following commands. 

        gcc -O1 quicksort.c   
        gcc -O2 quicksort.c   
        gcc -O3 quicksort.c   
        gcc -Os quicksort.c   
        clang -O1 quicksort.c 
        clang -O2 quicksort.c 
        clang -O3 quicksort.c 
        clang -Os quicksort.c 
        gcc -O1 fibo.c        
        gcc -O2 fibo.c        
        gcc -O3 fibo.c        
        gcc -Os fibo.c        
        clang -O1 fibo.c      
        clang -O2 fibo.c      
        clang -O3 fibo.c      
        clang -Os fibo.c      

... and produce the following output file structure

    2014-05-11_152521
    ├── README
    ├── time
    │   ├── time_TEST_PROGRAM.fibo.c_COMPILER_OPTIMIZATION_LEVEL
    │   └── time_TEST_PROGRAM.quicksort.c_COMPILER_OPTIMIZATION_LEVEL
    ├── mem
    │   ├── mem_TEST_PROGRAM.fibo.c_COMPILER_OPTIMIZATION_LEVEL
    │   └── mem_TEST_PROGRAM.quicksort.c_COMPILER_OPTIMIZATION_LEVEL
    └── output
        ├── TEST_PROGRAM.fibo.c_COMPILER.clang_OPTIMIZATION_LEVEL.O1.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.clang_OPTIMIZATION_LEVEL.O2.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.clang_OPTIMIZATION_LEVEL.O3.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.clang_OPTIMIZATION_LEVEL.Os.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.gcc_OPTIMIZATION_LEVEL.O1.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.gcc_OPTIMIZATION_LEVEL.O2.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.gcc_OPTIMIZATION_LEVEL.O3.out
        ├── TEST_PROGRAM.fibo.c_COMPILER.gcc_OPTIMIZATION_LEVEL.Os.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.clang_OPTIMIZATION_LEVEL.O1.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.clang_OPTIMIZATION_LEVEL.O2.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.clang_OPTIMIZATION_LEVEL.O3.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.clang_OPTIMIZATION_LEVEL.Os.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.gcc_OPTIMIZATION_LEVEL.O1.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.gcc_OPTIMIZATION_LEVEL.O2.out
        ├── TEST_PROGRAM.quicksort.c_COMPILER.gcc_OPTIMIZATION_LEVEL.O3.out
        └── TEST_PROGRAM.quicksort.c_COMPILER.gcc_OPTIMIZATION_LEVEL.Os.out
    
Where: 

- 2014-05-11_152521/ is the root directory for this experiment, named after the date in the YYYY-mm-dd_hhmmss format. 

- README is the README file described earlier. 

- time/ is the directory containing all the data points for execution time.

- time/time_TEST_PROGRAM.fibo.c_COMPILER_OPTIMIZATION_LEVEL one
  file. Remark that in the filename TEST_PROGRAM is the only parameter
  that is valued because TEST_PROGRAM file format is 'f' which stands
  for 'one value per file', other parameters such as compiler take
  different values in this file so the value is not reported in the
  filename.

- mem/ is the directory containing all the data points for maximum memory usage. Files are named following the same principle

- ouput/ is the directory containing the output (stdout and stderr) generated by the runs. There is one file per run so all the parameters are valued in the filename.

The content of the file time/time_TEST_PROGRAM.fibo.c_COMPILER_OPTIMIZATION_LEVEL is the following and should speak for itself. 

    # Experiment started on: 2014-05-11 15:25:22. 
    # Machine hostname: neb.
    # Timout for each run -1 s.  
    # Maximum memory usage allowed -0.0009765625 MiB.
    #
    # Reporting: Wall clock time (in seconds).
    #
    # OPTIMIZATION_LEVEL    COMPILER=gcc    COMPILER=clang
    O1      0.04    0.05
    O2      0.05    0.05
    O3      0.08    0.05
    Os      0.05    0.05

=head1 PARAMETERS 

Each parameter is declared with the -p switch as follows. (Multiple parameters are declared with multiple -p switch.)

    -p PARAMETER_NAME value1 value2 value3 ...

    
PARAMETER_NAME is the parameter name in capital letter and is followed
by all the parameters values (strings) separated by whitespaces. For example:

    -p COMPILER_NAME gcc clang

or

    -p NUM_THREADS 1 2 3 4

are both valid parameter lists. 

Remark that this is also possible:
    
    -p NUM_THREADS `seq 1 32`
    
=head1 USING EXPRESSION

The using expression serves two purposes: 

1. It describes how to combine the parameters values to build the
command lines from the command line template.
2. It describes the format specification to write the results into
files lines and columns with an adequate format. 

The using expression is composed of parameters names, operators and format descriptors. 

- Parameters names are the names (in capital letters) of the
  parameters formerly declared.

- Operators are  'x' or '=' 

    'x' (carthesian product)  combines all the values from the left operand with the values from the right operands

for example ('l' and 'c' are format descriptors, you can safely ignore them for now.): 

runtime -p A a1 a2 -p B b1 b2 -u AlxBc -- echo A B C 
will program the execution of:
    echo a1 b1
    echo a1 b2
    echo a2 b1
    echo a2 b2

    '='   maps all the values of the right operand to a value of the left operand with respect to the input value order. 

for example:

    runtime -p A a1 a2 -p B b1 b2 -u Al=Bc -- echo A B C
    
will program the execution of:
    
    echo a1 b1
    echo a2 b2

You can combine them, and use paranthesis:
    
    runtime -p A a1 a2 -p B b1 b2 -p C c1 c2 -u "(Ac=Bl)xCf" -- echo A B C 

will program the execution of: 
    echo a1 b1 c1
    echo a1 b1 c2
    echo a2 b2 c1
    echo a2 b2 c2

Note that if you introduce paranthesis, you must quote the using
expression.

=head1 FORMAT SPECIFICATION

Format descriptor are associated with parameters to describe how the
mesurements will be stored in the results files. 
They can be either 'f', 'l', or 'c'. 
- f stands for "one value per file" 
- l stands for "one value per line"
- c stands for "one value per column"

So:
    runtime -p A a1 a2 -p B b1 b2 -p C c1 c2 -u AfxBcxCl -- echo A B C 
    
Will create two files in the time output directory named:
time_A.a1_B_C and time_A.a2_B_C

Each file contains times measurements laid out as follows:
    # C     B=b1    B=b2
    c1      0.00    0.00
    c2      0.00    0.00
    
i.e. One value per column for parameter B and one value per line for
parameter C.

=head1 OUTPUT DIRECTORY

Each execution of runtime creates a directory named after the current date. 
The directory contains
 - a time subdirectory,
 - a mem subdirectory, 
 - a README file
 - a usr directory when a user script is provided. 

Each subdirectory contains the reporting files except the output sub
directory which contains the output of every execution.

=head1 SEE ALSO

gnuplot
    
=head1 AUTHOR

Benjamin Negrevergne, E<lt>bnegreve@gmail.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2010-2013 by Benjamin Negrevergne

This library is free software; you can redistribute it and/or modify
it under the terms of the GPLv3.

=cut
