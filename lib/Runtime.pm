package Runtime;

use 5.014002;
use strict;
use warnings;

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw(startup);

our $VERSION = '0.01';


use Proc::ProcessTable;

use Using;
use Using_Ast_Check;
use Result_Db;
use vars qw(%parameter_value_space);

our $using_ast; 

my $timeout = -1; #In sec, -1 is unlimited
my $mem_usage_cap = -1; #In kiB -1 is unlimited
my $total_memory; 


my $child_pid=-1; 
my $current_time = 0; 
my $current_process_name;
my $current_process_pid;
my $current_process_err;

my $CYCLE_LEN=1; #in sec. 
my $START_TIME = date_string();

my %opts;

my @runs =(); 


my $output_dir;

my $post_exec_script_path; 
my $max_mem_usage = 0; 
#my $current_bin_filename; 
my %params;
my $progtotest_command_template;
my %parameter_value_space; 
my @parameters_name; 
my @progtotest_command_lines; 
my @parameter_index_order; 
my %parameter_values; # bind parameter actual values to indices. 

our $errors = 0; 
our $runtime_bin_path = $0; 

sub error_args{
    die if @_ != 1; 
    print STDERR 'Error while parsing Runtime arguments: '.$_[0]."\n"; 
    $errors++;
    print "\n"; 
    print_usage();
    exit(1); 
}

sub warning_build_command_line{
    die if @_ != 1; 
    print STDERR 'Warning while building command line: '.$_[0]."\n";
    $errors++;
}

sub md5_file{
    my $file = $_[0];
    use Digest::MD5;
    open(FILE, $file) or die "Can't open '$file': $!";
    binmode(FILE);

    return Digest::MD5->new->addfile(*FILE)->hexdigest;
}

sub date_string{
    use POSIX qw/strftime/;
    return strftime('%F %T',localtime); 
}

sub date_string_ymd{
    use POSIX qw/strftime/;
    return strftime('%F',localtime); 
}


# Warning: may die; 
sub get_total_memory{
    die if @_ != 0; 
    
    open MEMINFO, "/proc/meminfo" or die $!; 
    while (my $line = <MEMINFO>){
	if($line =~ /MemTotal.*?([0-9]+).*/){
	    close MEMINFO; 
	    return $1; 
	}
    }
    die "Error: Cannot find out total memory.\n";
}

sub check_memory_usage{
    die if @_ != 0;
    open INPUT, 'ps -eo rss,command -w -w | awk \'/^[0-9]+ [^ ]*'.$current_process_name.'/ && !/awk/ {print $1}\'|'; 
    my $mem = <INPUT>;
    close INPUT;
    if($mem > $max_mem_usage){
	$max_mem_usage = $mem; 
    }
    return 0 if($mem_usage_cap == -1); 


    if($mem >= $mem_usage_cap){
	print STDERR "Process $current_process_name uses more than $mem_usage_cap kiB : $mem\n"; 
	return 1; 
    }
    return 0; 
}

sub check_timeout{
    die if @_ != 0; 
    return 0 if($timeout == -1);
    
    if($current_time >= $timeout){
	print STDERR "Process $current_process_name have been running for longer that $timeout sec (+- $CYCLE_LEN sec)\n"; 
	return 1; 
    }
    return 0; 
}

sub run_child{
    die if (@_ != 1); 
    my $command = $_[0];

#    $current_bin_filename = extract_bin_filename($command);
    $current_process_name = extract_process_name($command);
    $current_time = 0; 
    $current_process_err = "ERR_UKN";
    my $child_pid = fork;
    $current_process_pid = $child_pid;
    $max_mem_usage = 0; #reset mem usage 
    
    if (not $child_pid) {
	print "Executing: $command\n"; 
	
	exec "/usr/bin/time -o time.dat -f \"%e\" $command 2>&1 > /tmp/out_tmp " or die "command failed\n"; 
    }


    alarm $CYCLE_LEN;
    waitpid($child_pid, 0); 
    alarm 0;
    if($? != 0){
	return  ($current_process_err, $current_process_err, $current_process_err); 
    }
    
    my $time;
    open TIME_TMP, "time.dat" or die "cannot open time file\n";
    $time = <TIME_TMP>; 
    chop $time; 
    close TIME_TMP; 
    print "Run time : ".($time)." sec.\n";
    
    # executing post execution script
    my $pes_output; 
    if($post_exec_script_path){
	if(open(POST_EXEC_OUT,"-|", "cat /tmp/out_tmp | $post_exec_script_path")){
	    ($pes_output = <POST_EXEC_OUT>) or print STDERR "Warning: cannot read first line of output generated by user script \'$post_exec_script_path\'".$!."\n";
	    print "PES output $pes_output\n"; 
	    chop $pes_output; 
	    close(POST_EXEC_OUT); 
	} else{
	    print STDERR "Warning: cannot run post exec user script \'$post_exec_script_path\': ".$!.".\n"; 
	}
    }
    return ($time, $max_mem_usage/1024, $pes_output); 
}


sub print_usage{
    die if @_ != 0; 
    print STDERR "Usage: $runtime_bin_path -p PARAMETER_NAME parameter_value_1 .. parameter_value_n\
 [-p PARAMETER2_NAME parameter2_value_1 .. parameter2_value_n]\
 [-s post_output_script] [-m max_memory_usage (% total)] [ -t timeout value]\
 -u using_expression -- command_line_template\n";
 


    exit 0; 
}


sub get_hostname{
    die if @_ != 0; 
    use Sys::Hostname;
    my $hostname = hostname; 
    return $hostname; 
}
sub print_file_header{
    die if @_ != 1; 
    my ($bin) = @_; 
    my $md5 = md5_file($bin); 
    my $hostname = get_hostname(); 

    my $date = date_string();
        my $header_string = <<END;
# Experiment started on: @{[date_string()]}. 
# Machine hostname: $hostname.
# Timout for each run $timeout s.  
# Maximum memory usage allowed @{[$mem_usage_cap/1024]} MiB.;
#
END

    print TIME $header_string;
    print TIME "# Reporting: Wall clock time (in seconds).\n"; 

    print MEM $header_string; 
    print MEM  "# Reporting: Max memory usage (in MiB)"; 

    if($post_exec_script_path){
	print PES $header_string; 
	print PES "# Reporting: User script output."

    }
}


# Print system info and so on. 
sub print_info(){
    die if @_ != 0;

    if ($timeout == -1){ print "Timeout:\tUnlimited.\n"; }
    else { print "Timeout:\t$timeout (sec)\n";}

    print "Total memory:\t".($total_memory/1024)." MiB\n"; 
    if ($mem_usage_cap == -1){ print "Max memory usage:\tUnlimited.\n"; }
    else { print "Max memory usage:\t".($mem_usage_cap/1024)." MiB\n";}
    
    print "The following command lines will be executed:\n"; 
    print_progtest_command_lines();
}

# Extract process name from a command line. 
sub extract_process_name{
    die if @_ != 1; 
    my ($command) = @_;
    my $process_name = "unknwown_process"; 

    if( $command =~ /.*?\/?([\w\-]+)\s/gx){
	$process_name = $1;
    }
    else {
	print STDERR "Error: cannot parse process name \n"; 
    }
    return $process_name; 
}

# Extract bin file name from a command line. 
sub extract_bin_filename{
    die if @_ != 1; 
    my ($command) = @_;
    my $process_name = "unknwown_process"; 

    if( $command =~ /(.*?\/?[\w\-]+)\s/gx){
	$process_name = $1;
    }
    else {
	print STDERR "Error: cannot parse process name \n"; 
    }
    return $process_name; 
}


# Comparaison operator used for sort_tuples. 
sub compare_tuples{
    die if @_ != 2; 
    my ($t1_ref, $t2_ref) = @_; 

    foreach my $i (@parameter_index_order){
	return 1  if(@{$t1_ref}[$i] gt @{$t2_ref}[$i]);
	return -1 if(@{$t1_ref}[$i] lt @{$t2_ref}[$i]);
    }
    return 0; 
}

# Sort tuples in the fcl order.  The fcl (file, column, line) groups
# together the tuples that have the same value on an 'f' parameter,
# then the ones that have the same value on a 'l' parameter and so on. 
#
# Useful to group the execution that output in the same file. 
sub sort_tuples{
    die if @_ == 0;
    my @tuples = @_;
    
    # Compute parmeter orders to execute commands to the same file first. 
     @parameter_index_order = compute_flc_order(); 

    @tuples = sort { compare_tuples($a, $b) } @tuples; 
    return @tuples; 
}

sub create_dat_filename_suffix{
    die if @_ < 1; 
    my @tuple = @_;

    my $filename;
    
    my @parameters_names = @{$main::parameter_value_space{names}}; 
    my @parameters_decors = @{$main::parameter_value_space{decors}}; 

    foreach my $i (@parameter_index_order){
	if($parameters_decors[$i] eq 'f'){
	    my $value = $parameter_values{$parameters_names[$i]}->[$tuple[$i]]; 
	    $filename .= '.'.$parameters_names[$i].'-'.$value;
	}
	else{
	    $filename .= '.'.$parameters_names[$i]; 
	}
    }
    return $filename.'.dat'; 
}

sub create_dat_filename_suffix_full_valued{
    die if @_ < 1; 
    my @tuple = @_;
    my $filename;
    
    my @parameters_names = @{$main::parameter_value_space{names}}; 
    my @parameters_decors = @{$main::parameter_value_space{decors}}; 

    foreach my $i (@parameter_index_order){
	my $value = get_parameter_value($parameters_names[$i],$tuple[$i]); 
	$filename .= '.'.$parameters_names[$i].'-'.$value;
    }
    return $filename; 
}


sub start_file{
    die if @_ != 1; 
    my ($tuple) = @_;

    my $filename_suffix = create_dat_filename_suffix(@$tuple); 
    my $time_filename = $output_dir.'time/time'.$filename_suffix;
    my $mem_filename = $output_dir.'mem/mem'.$filename_suffix;
#    my $output_filename = $output_dir.'output/output'.$filename_suffix;

    open TIME, ">$time_filename" or print STDERR "Error: Cannot create file \'$time_filename\'\n";
    open MEM, ">$mem_filename" or print STDERR "Error: Cannot create file \'$time_filename\'\n";

    if($post_exec_script_path){
	my $pes_filename = $output_dir.'pes/pes'.$filename_suffix;
	open PES, ">$pes_filename" or print STDERR "Error: Cannot create file \'$time_filename\'\n";
    }
  #  print "NEW FILE     $time_filename\n";

    
    # this is just to find the bin name in order to compute the md5 in the file header 
    my $cl = 
	build_progtotest_command_line($progtotest_command_template,
				      $tuple, 0); 

    print_file_header(extract_bin_filename($cl)); 
}


sub end_file{
    my @all_command_lines = @_; 

    print TIME "\n####\n"; 
    print MEM "\n####\n"; 

    foreach my $cl (@all_command_lines){
	print TIME "# $cl (executable's md5 sum: ".md5_file(extract_bin_filename($cl)).")\n";
	print MEM "# $cl (executable's md5 sum: ".md5_file(extract_bin_filename($cl)).")\n";
    }    

    close TIME; 
    close MEM; 
    
#    close OUTPUT; 
}


sub start_line{
    die if @_ != 3; 
    my ($tuple, $tuple_range, $print_line_head) = @_;

    if($print_line_head){
#print line values 
	print TIME "#";
	print MEM "#";
	print PES "#" if $post_exec_script_path;

	foreach my $v (@parameter_index_order){
	    if($main::parameter_value_space{decors}->[$v] eq 'l'){
		start_column();
		my $parameter_name = $main::parameter_value_space{names}->[$v]; 
		print TIME "$parameter_name";
		print MEM "$parameter_name";
		print PES "$parameter_name" if $post_exec_script_path;
		end_column();
	    }
	}

	foreach my $v (@parameter_index_order){
	    if($main::parameter_value_space{decors}->[$v] eq 'c'){
		my $parameter_name = $main::parameter_value_space{names}->[$v]; 
		foreach my $t (@{$tuple_range}){
		    start_column();
		    print TIME "$parameter_name="
			.get_parameter_value($parameter_name, $t->[$v]); 
		    print MEM "$parameter_name="
			.get_parameter_value($parameter_name, $t->[$v]); 
		    print PES "$parameter_name="
			.get_parameter_value($parameter_name, $t->[$v]) if $post_exec_script_path; 

		    end_column();
		}
	    }
	}
	end_line();
    }
    
    foreach my $v (@parameter_index_order){
	start_column();
	if($main::parameter_value_space{decors}->[$v] eq 'l'){
	    my $parameter_name = $main::parameter_value_space{names}->[$v];
	    start_column(); 
	    print TIME get_parameter_value($parameter_name, $tuple->[$v]); 
	    print MEM get_parameter_value($parameter_name, $tuple->[$v]); 
	    print PES get_parameter_value($parameter_name, $tuple->[$v]) if $post_exec_script_path; 

	    end_column(); 
	}
    }

}
 

sub end_line{
    print TIME "\n"; 
    print MEM "\n";
    print PES "\n" if $post_exec_script_path; 
}

sub start_column{
    #   print "NEW COL\n"; 
}

sub end_column{
    print TIME "\t"; 
    print MEM "\t";
    print PES "\t" if $post_exec_script_path; 
}


sub get_parameter_value{
    die if @_ != 2; 
    my ($name, $index) = @_; 
    return $parameter_values{$name}->[$index];
}

# returns true if two tuple have equal value on a same level and level
# above level can be either 'f' 'l' or 'c' e.g. (a1, b2, c1) and (a1,
# b2, c2) are c-equal if c2 is the value of the first column
# parameter.
# 
sub tuple_level_compare{
    die if @_ != 3; 
    my ($t1_ref, $t2_ref, $level) = @_; 
    my $parameters_decors = $main::parameter_value_space{decors}; 

    # print "COMPARING : false\n"; 
    # print "TUPLE : ";print_tuple($t1_ref);
    # print "\n"; 
    # print "TUPLE : ";print_tuple($t2_ref); 
    # print "\n"; 
    
    my $below_level = 0; 
    foreach my $v (@parameter_index_order){
	my $decor = $parameters_decors->[$v]; 
	if ($below_level && (not $decor eq $level)) {return 1;}
	if(not $t1_ref->[$v] eq $t2_ref->[$v]){
	    return 0;
	}
	if ($decor eq $level){$below_level = 1;}
    }
    return 1; 
}



# given a tuple and a flc level return the larger (wrt flc order) that
# belong to the same class.
# e.g. (a1f, b1l, c1l, d1, e1), l
# will return 
# b1l, c1l, d1, e1
# b1l, c1l, d1, e2
# b1l, c1l, d2, e1
# b1l, c1l, d2, 
sub extract_tuple_class{
    die if @_ != 3; 
    my ($tuples, $tuple_index, $level) = @_; 

    my $end = $tuple_index; 
    while(my $retval = tuple_level_compare($tuples->[$tuple_index], $tuples->[$end], $level)){
#	print "RETVAL $retval\n"; 
	$end++;
    }
    $end--;
#    print "RETURNED $tuple_index, $end\n";
    return ($tuple_index, $end); 
}

sub run_command_lines{
    die if @_ != 0;
    my @parameters_names = @{$main::parameter_value_space{names}}; 
    my @parameters_decors = @{$main::parameter_value_space{decors}}; 
    
# A tuple is a possible set of parameter values in the parameter value space.

#    print_parameter_value_space(); 
    my $previous_tuple = -1; 
    my $filename; 

    my $tuple;
#    foreach  $tuple (sort_tuples @{$main::parameter_value_space{values}}){
    my @tuples_sorted = sort_tuples @{$main::parameter_value_space{values}}; 
    for (my $tuple_index = 0; $tuple_index <= $#tuples_sorted; $tuple_index++){
	my ($f_start, $f_end) = extract_tuple_class(\@tuples_sorted, $tuple_index, 'f');
#	print "FILE RANGE : $f_start, $f_end\n";
	if($f_end - $f_start != -1){
	    start_file($tuples_sorted[$f_start]);
	    my @file_cl = (); 
	    for (my $f_idx = $f_start; $f_idx <= $f_end; $f_idx++){
		my ($l_start, $l_end) = extract_tuple_class(\@tuples_sorted, $f_idx, 'l');
#		print "LINE RANGE : $l_start, $l_end\n"; 
		if($l_end - $l_start != -1){
		    start_line($tuples_sorted[$l_start], [@tuples_sorted[$l_start..$l_end]], $f_idx == $f_start);
		    for (my $l_idx = $l_start; $l_idx <= $l_end; $l_idx++){
			my ($c_start, $c_end) = 
			    extract_tuple_class(\@tuples_sorted, $l_idx, 'c');
#			print "COLONE RANGE : $l_idx $c_start, $c_end\n"; 
			if($c_end - $c_start != -1){
			    start_column($tuples_sorted[$c_start]);
			    foreach my $c_idx ($c_start .. $c_end){

				#RUN 
				$tuple = $tuples_sorted[$c_idx];

				my $cl = 
				    build_progtotest_command_line($progtotest_command_template,
								  $tuple,0);
				my ($time, $mem, $pes_output) =  run_child($cl);
				
				push @file_cl, $cl; 
				
				print TIME $time; 
				print MEM $mem; 
				print PES $pes_output if $post_exec_script_path; 

				# move child output file in the right place
				system ("mv /tmp/out_tmp $output_dir/output/output".create_dat_filename_suffix_full_valued(@{$tuple}).'.output');
				
			    }
			    end_column(); 

			}
		    $l_idx = $c_end;
		    }
		    end_line(); 
		}
		$f_idx = $l_end;
	    }
	    end_file(@file_cl); 
	    
	}
	$tuple_index = $f_end; 
    }
}

sub print_progtest_command_lines{
    foreach my $cl (@progtotest_command_lines){
	print ">>$cl<<\n"; 
    }
}

# Return an array of indexes in parameters names array so that any
# parameter name with a 'f' decor occurs before any parameter name
# with a 'l' decor and any parameter name with a 'l' decor occurs
# before any parameter name with a 'c' decor. 
sub compute_flc_order{
    die if @_  != 0;
    my @order; 
    my @parameter_names =  @{$main::parameter_value_space{names}};
    my @parameter_decors =  @{$main::parameter_value_space{decors}};

    for my $pi (0..$#parameter_names){
	if($parameter_decors[$pi] eq "f"){
	    push @order, $pi; 
	}
    }
    for my $pi (0..$#parameter_names){
	if($parameter_decors[$pi] eq "l"){
	    push @order, $pi; 
	}
    }
    for my $pi (0..$#parameter_names){
	if($parameter_decors[$pi] eq "c"){
	    push @order, $pi; 
	}
    }

    # print "MY ORDER \n"; 
    # foreach $v(@order){
    # 	print "$v "; 
    # }
    # print "\n";
    return @order; 
}


# Build a command line from a parameter tuples.
# Substitutes parameter names by corresponding values in the tuples. 
sub build_progtotest_command_line{
    die if @_ != 3;
    my ($command_line_template, $tuple, $print_warning) = @_;

    my @parameter_names =  @{$main::parameter_value_space{names}};
    
    my $command_line = $progtotest_command_template;
    for my $i (0..$#{$tuple}){
	unless ($command_line =~ s/$parameter_names[$i]/$parameter_values{$parameter_names[$i]}->[$tuple->[$i]]/g){
	    
	    print STDERR "Warning: Cannot subtitute parameter \'$parameter_names[$i]\' by value \'$parameter_values{$parameter_names[$i]}->[$tuple->[$i]]\' in command line template \'$progtotest_command_template\'.\n" if $print_warning;
	}
	
    }
    return $command_line; 
}

# helper function
sub print_parameter_value_space{
    die if @_ != 0;
    foreach my $v (sort_tuples @{$main::parameter_value_space{values}}){
	print_tuple($v); 
	print "\n";
    }
    
}

sub print_tuple{
    die if @_ != 1;
    my ($tuple) = @_;
    my @parameter_names =  @{$main::parameter_value_space{names}};
    
    foreach my $u (0..$#{$tuple}){
	print $parameter_names[$u].'['.$tuple->[$u].']'.':'.get_parameter_value($parameter_names[$u], $tuple->[$u])." \t";
    }	
    
}

sub build_progtotest_command_lines{
    die if @_ != 0; 

  
    foreach my $tuple (sort_tuples @{$main::parameter_value_space{values}}){
	push @progtotest_command_lines, build_progtotest_command_line($progtotest_command_template, $tuple, 1);
    }

}

sub check_progtotest_command_template{
    foreach my $param (keys %params){
	if($progtotest_command_template =~ /$param/){
#	    print "Found param \'$param\'$ in command line template.\n"; 
	}
	else{
	    print STDERR "Warning: param \'$param$\' not found in command line template.\n"; 
	}
    }
}


sub output_dir_default_name{
    die if @_ != 0; 
    my $output_dir = date_string().'/';

    $output_dir =~ s/ /_/g; 
    $output_dir =~ s/://g;

    return $output_dir; 
}

sub get_process_table{
    die if @_ != 0; 
     return new Proc::ProcessTable;
}

sub kill_process_tree{
    die if @_ != 1; 
    my ($pid) = @_;
    my $t = get_process_table;
    
    foreach my $p (@{$t->table}) {
	if($p->{"ppid"} == $pid){
	    kill_process_tree($p->{"pid"}); 
	}
	# if($p->{"pid"} == $pid){
	#     print "Killing".$p->{"cmndline"}."\n"; 
	# }
    }
    kill 9, $pid; 
}

sub init{
    die if @_ != 0; 

# memory 
    $total_memory = get_total_memory(); 

# initialize timer for the control loop
    $SIG {ALRM} = sub {
	$current_time+=$CYCLE_LEN; 
	my $mu = check_memory_usage();
	my $tu = check_timeout(); 
	if($mu or $tu){
	    print STDERR "killing $current_process_name.\n";
	    kill_process_tree($current_process_pid);
	    if($mu){
		$current_process_err = "ERR_MEM"; 
	    }
	    else{
		$current_process_err = "ERR_TME"; 
	    }

	    sleep(1); 
	}
	else {
	    alarm $CYCLE_LEN;
	}
    };

    $output_dir = output_dir_default_name(); 
    
}

# records a new parameter and its possible values
sub add_parameter_values{
     die if @_ != 2; 
     my ($p_name, $value_space_ref) =  @_; 
     $parameter_values{$p_name} = $value_space_ref; 
     Using::add_parameter_range($p_name, $#{$value_space_ref}+1); 
}


sub create_readme_file{
    die if @_ < 1; 
    my @argv = @_;
    open README, ">$output_dir/README.tmp" or die $!;

    print README "\n###########################\n";
    print README "Experiment started at $START_TIME on ".get_hostname().".\n";
    print README "$0 ".join(' ',@argv);

    print README "\n\n\n"; 
    foreach my $cl (@progtotest_command_lines){
	print README "$cl\n"; 
    }    
    print README "\n"; 
    close README; 
 }

sub finalize_readme_file{
    die if @_ != 0;
    open README, ">>$output_dir/README" or die $!;
    open READMETMP, "$output_dir/README.tmp" or die $!;
    while (my $line = <READMETMP>){
	print README $line; 
    }
    close READMETMP;
    print README "Expeperiment finished at ".date_string."\n";
    close README;
    system ("rm -f $output_dir/README.tmp"); 
    
}

sub populate_output_dir{
    die if @_ != 1; 
    my ($output_dir) = @_;

    system("mkdir -p $output_dir/"); 
    system("mkdir -p $output_dir/time"); 
    system("mkdir -p $output_dir/mem"); 
    system("mkdir -p $output_dir/output");
    system("mkdir -p $output_dir/pes") if $post_exec_script_path; 
}

sub parse_program_arguments{
    $#_ == 0 or die "Unexpected argument number.\n"; 
    my @argv = @{$_[0]}; 

    while (my $arg = shift @argv){
	if($arg =~ /\-([putmso-])/){

	    ####################
	    #### parameters ####
	    ####################
	    if($1 eq 'p'){
		# parse a param argument
		# creates a param entry with a list of values for this param
		if(defined(my $p_name = shift @argv)){
		    if(not $p_name =~ /[a-zA-Z_][a-zA-Z_0-9]*/){
			error_args "Parameter '$p_name' is not a valid parameter name (parameter names must match [a-zA-Z_][a-zA-Z_0-9]*.";
		    }
		    
		    my @values = (); 
		    while(defined (my $n = shift @argv)){
			if($n =~ /^-/){
			    unshift @argv, $n; 
			    last; 
			}
			push @values, $n; 
		    }
		    if(@values != 0){
			declare_parameter($p_name, @values); 
		    }
		    else{
			error_args "No value provided for parameter '$p_name'.";
		    }
		}
		else{
		    print_usage(); 
		}
	    }

	    ###############
	    #### using ####
	    ###############
	    elsif($1 eq 'u'){
		if(defined(my $param = shift @argv)){
		    foreach my $param_name (keys %params){
			declare_parameter($param_name, $params{$param_name}); 
		    }

		    $using_ast = Using::parse($param);
		}
		else{
		    print_usage();
		}
	    }

	    #################
	    #### timeout ####
	    #################	    
	    elsif($1 eq 't'){
		if(defined(my $param = shift @argv)){
		    $timeout = $param; 
		    if($timeout <= $CYCLE_LEN){
			print STDERR "Warning: timout value ($timeout sec) is below timeout resolution ($CYCLE_LEN sec).\n"; }
		}
		else{
		    print_usage; 
		}
	    }

	    ######################
	    #### memory limit ####
	    ######################	    
	    elsif($1 eq 'm'){
		if(defined(my $param = shift @argv)){
		    $mem_usage_cap = $param * $total_memory / 100; 
		}
		else{
		    print_usage; 
		}
	    }


	    ##########################
	    #### post exec script ####
	    ##########################	    
	    elsif($1 eq 's'){
		if(defined(my $param = shift @argv)){
		    $post_exec_script_path = $param;

		}
		else{
		    print_usage; 
		}
	    }

	    #################################
	    #### use existing output dir ####
	    #################################	    
	    elsif($1 eq 'o'){
		if(defined(my $param = shift @argv)){
		    $output_dir = $param.'/';
		}
		else{
		    print_usage;
		}
	    }
	    
	    elsif($1 eq '-'){
		if(@argv == 0) {print_usage; die "Cannot parse command line\n";}
		
		$progtotest_command_template = join(' ',@argv);
		@argv=(); 
	    }
	    else{
		print_usage;
		die; 
	    }

	}
    }
}


# Build a command line from the command line template and a tuple of
# value references.
#
# Iterate through the template and replace occurrences of PNAME with
# value refered by the first value reference <PNAME, value_index>.
# Warning: If the same PNAME occurs multiple times, each occurrence is
# only replaced once for each value reference (left-most occurrences
# are replaced first.)
sub build_a_command_line{
    die if @_ != 2; 
    my $template = $_[0];
    my @tuple = @{$_[1]}; 

    foreach my $vr(@tuple){
	my $pname = value_ref_get_pname($vr);
	my $value = value_ref_get_value($vr);

	if(not ($template =~ s/$pname/$value/)){
	    warning_build_command_line
		"Parameter '$pname' not found in command line template."; 
	}
    }
    return $template;     
}


# Build a dimension name from a tuple and a dimension specification
# (i.e. f c or l).  
#
# e.g. tuple_build_dim_name([ <A:1> <B:2> <C:1> <D:2> ], 'l') will
# return the string "C.1_D.2" if the dimension specification is "fcll" 
# (file column line line)
sub tuple_build_dim_name{
    die if @_ != 2; 
    my ($tuple, $dim_name) = @_;
    my $string = "";
    my @dims_index = ast_get_dimension_indexes($using_ast, $dim_name);

    my $i = 0; 
    foreach my $vr_index(@dims_index){
	$string .= value_ref_get_pname($tuple->[$vr_index]).".".value_ref_get_value($tuple->[$vr_index]);
	if(++$i != @dims_index){
	    $string .= '_';     
	}
    }
    return $string; 
}


# Convert a tuple into a filename
sub tuple_to_filename{
    die if @_ != 1; 
    my ($tuple) = @_;
    my $string = "";
    my @file_dims = ast_get_dimension_indexes($using_ast, "f");
    my @cols_dims = ast_get_dimension_indexes($using_ast, "c");
    my @line_dims = ast_get_dimension_indexes($using_ast, "l"); 
    my $total = @file_dims + @cols_dims + @line_dims; 

    my $i = 0; 

    foreach my $d (@file_dims){
	my $vr = $tuple->[$d]; 
	$string .= value_ref_get_pname($vr);
	$string .= '.'.value_ref_get_value($vr);
	if(++$i != $total){
	    $string .= '_';
	}
    }
    foreach my $d (@cols_dims){
	my $vr = $tuple->[$d]; 
	$string .= value_ref_get_pname($vr);
	if(++$i != $total){
	    $string .= '_';
	}
    }
    foreach my $d (@line_dims){
	my $vr = $tuple->[$d]; 
	$string .= value_ref_get_pname($vr);
	if(++$i != $total){
	    $string .= '_';
	}
    }
    return $string; 
}

# Store a result in a structed db. 
sub store_result{
    die if @_ != 3;
    my ($tag, $tuple, $result_string) = @_; 

    result_db_insert_value(tuple_to_filename($tuple), tuple_build_dim_name($tuple, 'c'),
			   tuple_build_dim_name($tuple, 'l'), $result_string);
}

# # add a value in the result db
# sub result_db_insert_value{
#     die if @_ != 4; 
#     my ($filename_id, $column_id, $line_id, $value_string) = @_; 

#     if(not defined $result_db{$filename_id}){
# 	$result_db{$filename_id} = {data => {}, dirty => 1};
#     }

#     $result_db{$filename_id}{dirty} = 1;
#     # if(not defined $result_db{$filename_id}{data}{$column_id}{$line_id}){
#     # 	$result_db{$filename_id}{data}{$column_id}{$line_id} = (); 
#     # }

#     $result_db{$filename_id}{data}{$line_id}{$column_id} = $value_string; 
# }

# sub print_result_db{
#     foreach my $f (keys %result_db){
# 	print "FILE: $f\n#";
# 	foreach my $c (keys $result_db{$f}{data}){
# 	    foreach my $l (keys $result_db{$f}{data}{$c}){
# 		print "$l"; 
# 	    }
# 	    print "\t"; 
# 	}
# 	print "\n"; 
# 	foreach my $c (keys $result_db{$f}{data}){
# 	    foreach my $l (keys $result_db{$f}{data}{$c}){
# 	    }
# 	    print "$c\t";
# 	    foreach my $l (keys $result_db{$f}{data}{$c}){
# 		print $result_db{$f}{data}{$c}{$l}."\t";
# 	    }
# 	    print "\n"; 
# 	}
# 	print "\n\n"; 
#     }
# }

sub startup{
    my @argv = @_; 
    init(); 
    parse_program_arguments(\@argv);
#    print ast_to_string($using_ast);
    check_ast($using_ast);
    print ast_to_string($using_ast);
    populate_output_dir($output_dir);
    result_db_init($output_dir);
    
    my @tuples = @{ast_get_tuples($using_ast)};

    my @command_lines = (); 

    foreach my $t (@tuples){
	result_db_add_tuple($t);
	my $cl = build_a_command_line($progtotest_command_template, $t);
	my ($time, $mem, $pes_output) =  run_child($cl);
	result_db_set_result($t, $time);
    }
    
    # foreach my $c  (@command_lines){
    # 	print "<<$c>>\n"; 
    # }
    
    return 1; 
    # check_progtotest_command_template(); 
    # build_progtotest_command_lines();
    
    # print "\n";
    # print_info();

     create_readme_file(@argv); 
     run_command_lines(); 

    # finalize_readme_file(); 
    # print "END: ".date_string."\n";
    # print "Results are in: ".$output_dir."\n";
    # system ("rm -f last_xp"); 
    # system ("ln -s  $output_dir last_xp"); 
}

1;
__END__
# Below is stub documentation for your module. You'd better edit it!

=head1 NAME

runtime - Perl extension for blah blah blah

=head1 SYNOPSIS

  use runtime;
  blah blah blah

=head1 DESCRIPTION

Runtime can be used to measure and plot statistics such as time or
memory usage on programs with a (possibly large) number of parameters.

For example the following command:

 $> runtime -p P1 a1 a2 -p P2 b1 b2 b3 -u P1cxP2l -- echo P1 P2

will 
1. Run the following commands 

echo a1 b1
echo a1 b2
echo a1 b3
echo a2 b1
echo a2 b2
echo a2 b3

2. Collect time statistics and store them into file. 
One value per column for P1, one value per line for P2.


Essentially Runtime is a tool to map points in a high dimensional
space (the space of parameters) onto the three dimensional space that
consists in columns, lines, and files.





Stub documentation for runtime, created by h2xs. It looks like the
author of the extension was negligent enough to leave the stub
unedited.

Blah blah blah.

=head2 EXPORT

None by default.



=head1 SEE ALSO

Mention other useful documentation such as the documentation of
related modules or operating system documentation (such as man pages
in UNIX), or any relevant external documentation such as RFCs or
standards.

If you have a mailing list set up for your module, mention it here.

If you have a web site set up for your module, mention it here.

=head1 AUTHOR

Benjamin Negrevergne, E<lt>benjamin@E<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013 by Benjamin Negrevergne

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.


=cut










