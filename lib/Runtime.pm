package Runtime;

use 5.014002;
use strict;
use warnings;

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw(startup);

our $VERSION = '0.01';


use Proc::ProcessTable;

use Using;
use Using_Ast_Check;
use Result_Db;
use vars qw(%parameter_value_space);

our $using_ast; 


my $LINE_RESULT_SEPARATOR = "\n"; 
my $COLUMN_RESULT_SEPARATOR = "\t"; 
# In case there are multiple parameters with the same format spec, how to deparate them.
# e.g. AfxBcxClxDl,
my $CELL_RESULT_SEPARATOR = ':'; 

my $timeout = -1; #In sec, -1 is unlimited
my $mem_usage_cap = -1; #In kiB -1 is unlimited
my $total_memory; 


my $child_pid=-1; 
my $current_time = 0; 
my $current_process_name;
my $current_process_pid;
my $current_process_err;

my $CYCLE_LEN=1; #in sec. 
my $START_TIME = date_string();

my %opts;

my @runs =(); 


my $output_dir;

my $post_exec_script_path; 
my $max_mem_usage = 0; 
#my $current_bin_filename; 
my %params;
my $progtotest_command_template;
my %parameter_value_space; 
my @parameters_name; 
my @progtotest_command_lines; 
my @parameter_index_order; 
my %parameter_values; # bind parameter actual values to indices. 

our $errors = 0; 
our $runtime_bin_path = $0; 



sub error_args{
    die if @_ != 1; 
    print STDERR 'Error while parsing Runtime arguments: '.$_[0]."\n"; 
    $errors++;
    print "\n"; 
    print_usage();
    exit(1); 
}


sub warning_output{
    die if @_ != 1; 
    print STDERR 'Warning, while writing result files: '.$_[0].".\n"; 
    $errors++;
}

sub warning_build_command_line{
    die if @_ != 1; 
    print STDERR 'Warning while building command line: '.$_[0]."\n";
    $errors++;
}

sub md5_file{
    die if @_ != 1; 
    my $file = $_[0];
    use Digest::MD5;
    
    my $md5; 
    if(open(FILE, $file)){
    binmode(FILE);
    $md5 = Digest::MD5->new->addfile(*FILE)->hexdigest;
    }
    else{
	warning_output "Cannot compute binary md5 file for '$file': ".$!;
	$md5 = "(Cannot compute md5 for file: '$file')"; 
    }
    return $md5; 
}

sub date_string{
    use POSIX qw/strftime/;
    return strftime('%F %T',localtime); 
}

sub date_string_ymd{
    use POSIX qw/strftime/;
    return strftime('%F',localtime); 
}


# Warning: may die; 
sub get_total_memory{
    die if @_ != 0; 
    
    open MEMINFO, "/proc/meminfo" or die $!; 
    while (my $line = <MEMINFO>){
	if($line =~ /MemTotal.*?([0-9]+).*/){
	    close MEMINFO; 
	    return $1; 
	}
    }
    die "Error: Cannot find out total memory.\n";
}

sub check_memory_usage{
    die if @_ != 0;
    open INPUT, 'ps -eo rss,command -w -w | awk \'/^[0-9]+ [^ ]*'.$current_process_name.'/ && !/awk/ {print $1}\'|'; 
    my $mem = <INPUT>;
    close INPUT;
    if($mem > $max_mem_usage){
	$max_mem_usage = $mem; 
    }
    return 0 if($mem_usage_cap == -1); 


    if($mem >= $mem_usage_cap){
	print STDERR "Process $current_process_name uses more than $mem_usage_cap kiB : $mem\n"; 
	return 1; 
    }
    return 0; 
}

sub check_timeout{
    die if @_ != 0; 
    return 0 if($timeout == -1);
    
    if($current_time >= $timeout){
	print STDERR "Process $current_process_name have been running for longer that $timeout sec (+- $CYCLE_LEN sec)\n"; 
	return 1; 
    }
    return 0; 
}

sub run_child{
    die if (@_ != 1); 
    my $command = $_[0];

#    $current_bin_filename = extract_bin_filename($command);
    $current_process_name = extract_process_name($command);
    $current_time = 0; 
    $current_process_err = "ERR_UKN";
    my $child_pid = fork;
    $current_process_pid = $child_pid;
    $max_mem_usage = 0; #reset mem usage 
    
    if (not $child_pid) {
	print "Executing: $command\n"; 
	
	exec "/usr/bin/time -o time.dat -f \"%e\" $command 2>&1 > /tmp/out_tmp " or die "command failed\n"; 
    }


    alarm $CYCLE_LEN;
    waitpid($child_pid, 0); 
    alarm 0;
    if($? != 0){
	return  ($current_process_err, $current_process_err, $current_process_err); 
    }
    
    my $time;
    open TIME_TMP, "time.dat" or die "cannot open time file\n";
    $time = <TIME_TMP>; 
    chop $time; 
    close TIME_TMP; 
    print "Run time : ".($time)." sec.\n";
    
    # executing post execution script
    my $pes_output; 
    if($post_exec_script_path){
	if(open(POST_EXEC_OUT,"-|", "cat /tmp/out_tmp | $post_exec_script_path")){
	    ($pes_output = <POST_EXEC_OUT>) or print STDERR "Warning: cannot read first line of output generated by user script \'$post_exec_script_path\'".$!."\n";
	    print "PES output $pes_output\n"; 
	    chop $pes_output; 
	    close(POST_EXEC_OUT); 
	} else{
	    print STDERR "Warning: cannot run post exec user script \'$post_exec_script_path\': ".$!.".\n"; 
	}
    }
    return ($time, $max_mem_usage/1024, $pes_output); 
}


sub print_usage{
    die if @_ != 0; 
    print STDERR "Usage: $runtime_bin_path -p PARAMETER_NAME parameter_value_1 .. parameter_value_n\
 [-p PARAMETER2_NAME parameter2_value_1 .. parameter2_value_n]\
 [-s post_output_script] [-m max_memory_usage (% total)] [ -t timeout value]\
 -u using_expression -- command_line_template\n";
 


    exit 0; 
}


sub get_hostname{
    die if @_ != 0; 
    use Sys::Hostname;
    my $hostname = hostname; 
    return $hostname; 
}

# print a description in the file handled by fh
# bin is the binary file name executed
# info reported is a string describing what is reported, e.g. time. 
sub print_file_header{
    die if @_ != 3; 
    my ($fh, $bin, $info_reported) = @_; 
    my $md5 = md5_file($bin); 
    my $hostname = get_hostname(); 

    my $date = date_string();
        my $header_string = <<END;
# Experiment started on: @{[date_string()]}. 
# Machine hostname: $hostname.
# Timout for each run $timeout s.  
# Maximum memory usage allowed @{[$mem_usage_cap/1024]} MiB.
#
# Reporting: $info_reported.
#
END
    print $fh $header_string;
}


# Print system info. 
sub print_info(){
    die if @_ != 0;

    if ($timeout == -1){ print "Timeout:\tUnlimited.\n"; }
    else { print "Timeout:\t$timeout (sec)\n";}

    print "Total memory:\t".($total_memory/1024)." MiB\n"; 
    if ($mem_usage_cap == -1){ print "Max memory usage:\tUnlimited.\n"; }
    else { print "Max memory usage:\t".($mem_usage_cap/1024)." MiB\n";}
    
    print "The following command lines will be executed:\n"; 
    print_progtest_command_lines();
}

# Extract process name from a command line. 
sub extract_process_name{
    die if @_ != 1; 
    my ($command) = @_;
    my $process_name = "unknwown_process"; 

    if( $command =~ /.*?\/?([\w\-]+)\s/gx){
	$process_name = $1;
    }
    else {
	print STDERR "Error: cannot parse process name \n"; 
    }
    return $process_name; 
}

# Extract bin file name from a command line. 
sub extract_bin_filename{
    die if @_ != 1; 
    my ($command) = @_;
    my $process_name = "unknwown_process"; 

    if( $command =~ /(.*?\/?[\w\-]+)\s/gx){
	$process_name = $1;
    }
    else {
	print STDERR "Error: cannot parse process name \n"; 
    }
    return $process_name; 
}


# Comparaison operator used for sort_tuples. 
sub compare_tuples{
    die if @_ != 2; 
    my ($t1_ref, $t2_ref) = @_; 

    foreach my $i (@parameter_index_order){
	return 1  if(@{$t1_ref}[$i] gt @{$t2_ref}[$i]);
	return -1 if(@{$t1_ref}[$i] lt @{$t2_ref}[$i]);
    }
    return 0; 
}

# Sort tuples in the fcl order.  The fcl (file, column, line) groups
# together the tuples that have the same value on an 'f' parameter,
# then the ones that have the same value on a 'l' parameter and so on. 
#
# Useful to group the execution that output in the same file. 
sub sort_tuples{
    die if @_ == 0;
    my @tuples = @_;
    
    # Compute parmeter orders to execute commands to the same file first. 
     @parameter_index_order = compute_flc_order(); 

    @tuples = sort { compare_tuples($a, $b) } @tuples; 
    return @tuples; 
}

sub create_dat_filename_suffix{
    die if @_ < 1; 
    my @tuple = @_;

    my $filename;
    
    my @parameters_names = @{$main::parameter_value_space{names}}; 
    my @parameters_decors = @{$main::parameter_value_space{decors}}; 

    foreach my $i (@parameter_index_order){
	if($parameters_decors[$i] eq 'f'){
	    my $value = $parameter_values{$parameters_names[$i]}->[$tuple[$i]]; 
	    $filename .= '.'.$parameters_names[$i].'-'.$value;
	}
	else{
	    $filename .= '.'.$parameters_names[$i]; 
	}
    }
    return $filename.'.dat'; 
}

sub create_dat_filename_suffix_full_valued{
    die if @_ < 1; 
    my @tuple = @_;
    my $filename;
    
    my @parameters_names = @{$main::parameter_value_space{names}}; 
    my @parameters_decors = @{$main::parameter_value_space{decors}}; 

    foreach my $i (@parameter_index_order){
	my $value = get_parameter_value($parameters_names[$i],$tuple[$i]); 
	$filename .= '.'.$parameters_names[$i].'-'.$value;
    }
    return $filename; 
}


sub start_file{
    die if @_ != 1; 
    my ($tuple) = @_;

    my $filename_suffix = create_dat_filename_suffix(@$tuple); 
    my $time_filename = $output_dir.'time/time'.$filename_suffix;
    my $mem_filename = $output_dir.'mem/mem'.$filename_suffix;
#    my $output_filename = $output_dir.'output/output'.$filename_suffix;

    open TIME, ">$time_filename" or print STDERR "Error: Cannot create file \'$time_filename\'\n";
    open MEM, ">$mem_filename" or print STDERR "Error: Cannot create file \'$time_filename\'\n";

    if($post_exec_script_path){
	my $pes_filename = $output_dir.'pes/pes'.$filename_suffix;
	open PES, ">$pes_filename" or print STDERR "Error: Cannot create file \'$time_filename\'\n";
    }
  #  print "NEW FILE     $time_filename\n";

    
    # this is just to find the bin name in order to compute the md5 in the file header 
    my $cl = 
	build_progtotest_command_line($progtotest_command_template,
				      $tuple, 0); 

    print_file_header(extract_bin_filename($cl)); 
}


sub end_file{
    my @all_command_lines = @_; 

    print TIME "\n####\n"; 
    print MEM "\n####\n"; 

    foreach my $cl (@all_command_lines){
	print TIME "# $cl (executable's md5 sum: ".md5_file(extract_bin_filename($cl)).")\n";
	print MEM "# $cl (executable's md5 sum: ".md5_file(extract_bin_filename($cl)).")\n";
    }    

    close TIME; 
    close MEM; 
    
#    close OUTPUT; 
}


sub start_line{
    die if @_ != 3; 
    my ($tuple, $tuple_range, $print_line_head) = @_;

    if($print_line_head){
#print line values 
	print TIME "#";
	print MEM "#";
	print PES "#" if $post_exec_script_path;

	foreach my $v (@parameter_index_order){
	    if($main::parameter_value_space{decors}->[$v] eq 'l'){
		start_column();
		my $parameter_name = $main::parameter_value_space{names}->[$v]; 
		print TIME "$parameter_name";
		print MEM "$parameter_name";
		print PES "$parameter_name" if $post_exec_script_path;
		end_column();
	    }
	}

	foreach my $v (@parameter_index_order){
	    if($main::parameter_value_space{decors}->[$v] eq 'c'){
		my $parameter_name = $main::parameter_value_space{names}->[$v]; 
		foreach my $t (@{$tuple_range}){
		    start_column();
		    print TIME "$parameter_name="
			.get_parameter_value($parameter_name, $t->[$v]); 
		    print MEM "$parameter_name="
			.get_parameter_value($parameter_name, $t->[$v]); 
		    print PES "$parameter_name="
			.get_parameter_value($parameter_name, $t->[$v]) if $post_exec_script_path; 

		    end_column();
		}
	    }
	}
	end_line();
    }
    
    foreach my $v (@parameter_index_order){
	start_column();
	if($main::parameter_value_space{decors}->[$v] eq 'l'){
	    my $parameter_name = $main::parameter_value_space{names}->[$v];
	    start_column(); 
	    print TIME get_parameter_value($parameter_name, $tuple->[$v]); 
	    print MEM get_parameter_value($parameter_name, $tuple->[$v]); 
	    print PES get_parameter_value($parameter_name, $tuple->[$v]) if $post_exec_script_path; 

	    end_column(); 
	}
    }

}
 

sub end_line{
    print TIME "\n"; 
    print MEM "\n";
    print PES "\n" if $post_exec_script_path; 
}

sub start_column{
    #   print "NEW COL\n"; 
}

sub end_column{
    print TIME "\t"; 
    print MEM "\t";
    print PES "\t" if $post_exec_script_path; 
}


sub get_parameter_value{
    die if @_ != 2; 
    my ($name, $index) = @_; 
    return $parameter_values{$name}->[$index];
}

# returns true if two tuple have equal value on a same level and level
# above level can be either 'f' 'l' or 'c' e.g. (a1, b2, c1) and (a1,
# b2, c2) are c-equal if c2 is the value of the first column
# parameter.
# 
sub tuple_level_compare{
    die if @_ != 3; 
    my ($t1_ref, $t2_ref, $level) = @_; 
    my $parameters_decors = $main::parameter_value_space{decors}; 

    # print "COMPARING : false\n"; 
    # print "TUPLE : ";print_tuple($t1_ref);
    # print "\n"; 
    # print "TUPLE : ";print_tuple($t2_ref); 
    # print "\n"; 
    
    my $below_level = 0; 
    foreach my $v (@parameter_index_order){
	my $decor = $parameters_decors->[$v]; 
	if ($below_level && (not $decor eq $level)) {return 1;}
	if(not $t1_ref->[$v] eq $t2_ref->[$v]){
	    return 0;
	}
	if ($decor eq $level){$below_level = 1;}
    }
    return 1; 
}



# given a tuple and a flc level return the larger (wrt flc order) that
# belong to the same class.
# e.g. (a1f, b1l, c1l, d1, e1), l
# will return 
# b1l, c1l, d1, e1
# b1l, c1l, d1, e2
# b1l, c1l, d2, e1
# b1l, c1l, d2, 
sub extract_tuple_class{
    die if @_ != 3; 
    my ($tuples, $tuple_index, $level) = @_; 

    my $end = $tuple_index; 
    while(my $retval = tuple_level_compare($tuples->[$tuple_index], $tuples->[$end], $level)){
#	print "RETVAL $retval\n"; 
	$end++;
    }
    $end--;
#    print "RETURNED $tuple_index, $end\n";
    return ($tuple_index, $end); 
}

sub run_command_lines{
    die if @_ != 0;
    my @parameters_names = @{$main::parameter_value_space{names}}; 
    my @parameters_decors = @{$main::parameter_value_space{decors}}; 
    
# A tuple is a possible set of parameter values in the parameter value space.

#    print_parameter_value_space(); 
    my $previous_tuple = -1; 
    my $filename; 

    my $tuple;
#    foreach  $tuple (sort_tuples @{$main::parameter_value_space{values}}){
    my @tuples_sorted = sort_tuples @{$main::parameter_value_space{values}}; 
    for (my $tuple_index = 0; $tuple_index <= $#tuples_sorted; $tuple_index++){
	my ($f_start, $f_end) = extract_tuple_class(\@tuples_sorted, $tuple_index, 'f');
#	print "FILE RANGE : $f_start, $f_end\n";
	if($f_end - $f_start != -1){
	    start_file($tuples_sorted[$f_start]);
	    my @file_cl = (); 
	    for (my $f_idx = $f_start; $f_idx <= $f_end; $f_idx++){
		my ($l_start, $l_end) = extract_tuple_class(\@tuples_sorted, $f_idx, 'l');
#		print "LINE RANGE : $l_start, $l_end\n"; 
		if($l_end - $l_start != -1){
		    start_line($tuples_sorted[$l_start], [@tuples_sorted[$l_start..$l_end]], $f_idx == $f_start);
		    for (my $l_idx = $l_start; $l_idx <= $l_end; $l_idx++){
			my ($c_start, $c_end) = 
			    extract_tuple_class(\@tuples_sorted, $l_idx, 'c');
#			print "COLONE RANGE : $l_idx $c_start, $c_end\n"; 
			if($c_end - $c_start != -1){
			    start_column($tuples_sorted[$c_start]);
			    foreach my $c_idx ($c_start .. $c_end){

				#RUN 
				$tuple = $tuples_sorted[$c_idx];

				my $cl = 
				    build_progtotest_command_line($progtotest_command_template,
								  $tuple,0);
				my ($time, $mem, $pes_output) =  run_child($cl);
				
				push @file_cl, $cl; 
				
				print TIME $time; 
				print MEM $mem; 
				print PES $pes_output if $post_exec_script_path; 

				# move child output file in the right place
				system ("mv /tmp/out_tmp $output_dir/output/output".create_dat_filename_suffix_full_valued(@{$tuple}).'.output');
				
			    }
			    end_column(); 

			}
		    $l_idx = $c_end;
		    }
		    end_line(); 
		}
		$f_idx = $l_end;
	    }
	    end_file(@file_cl); 
	    
	}
	$tuple_index = $f_end; 
    }
}

sub print_progtest_command_lines{
    foreach my $cl (@progtotest_command_lines){
	print ">>$cl<<\n"; 
    }
}

# Return an array of indexes in parameters names array so that any
# parameter name with a 'f' decor occurs before any parameter name
# with a 'l' decor and any parameter name with a 'l' decor occurs
# before any parameter name with a 'c' decor. 
sub compute_flc_order{
    die if @_  != 0;
    my @order; 
    my @parameter_names =  @{$main::parameter_value_space{names}};
    my @parameter_decors =  @{$main::parameter_value_space{decors}};

    for my $pi (0..$#parameter_names){
	if($parameter_decors[$pi] eq "f"){
	    push @order, $pi; 
	}
    }
    for my $pi (0..$#parameter_names){
	if($parameter_decors[$pi] eq "l"){
	    push @order, $pi; 
	}
    }
    for my $pi (0..$#parameter_names){
	if($parameter_decors[$pi] eq "c"){
	    push @order, $pi; 
	}
    }

    # print "MY ORDER \n"; 
    # foreach $v(@order){
    # 	print "$v "; 
    # }
    # print "\n";
    return @order; 
}


# Build a command line from a parameter tuples.
# Substitutes parameter names by corresponding values in the tuples. 
sub build_progtotest_command_line{
    die if @_ != 3;
    my ($command_line_template, $tuple, $print_warning) = @_;

    my @parameter_names =  @{$main::parameter_value_space{names}};
    
    my $command_line = $progtotest_command_template;
    for my $i (0..$#{$tuple}){
	unless ($command_line =~ s/$parameter_names[$i]/$parameter_values{$parameter_names[$i]}->[$tuple->[$i]]/g){
	    
	    print STDERR "Warning: Cannot subtitute parameter \'$parameter_names[$i]\' by value \'$parameter_values{$parameter_names[$i]}->[$tuple->[$i]]\' in command line template \'$progtotest_command_template\'.\n" if $print_warning;
	}
	
    }
    return $command_line; 
}

# helper function
sub print_parameter_value_space{
    die if @_ != 0;
    foreach my $v (sort_tuples @{$main::parameter_value_space{values}}){
	print_tuple($v); 
	print "\n";
    }
    
}

sub print_tuple{
    die if @_ != 1;
    my ($tuple) = @_;
    my @parameter_names =  @{$main::parameter_value_space{names}};
    
    foreach my $u (0..$#{$tuple}){
	print $parameter_names[$u].'['.$tuple->[$u].']'.':'.get_parameter_value($parameter_names[$u], $tuple->[$u])." \t";
    }	
    
}

sub build_progtotest_command_lines{
    die if @_ != 0; 

  
    foreach my $tuple (sort_tuples @{$main::parameter_value_space{values}}){
	push @progtotest_command_lines, build_progtotest_command_line($progtotest_command_template, $tuple, 1);
    }

}

sub check_progtotest_command_template{
    foreach my $param (keys %params){
	if($progtotest_command_template =~ /$param/){
#	    print "Found param \'$param\'$ in command line template.\n"; 
	}
	else{
	    print STDERR "Warning: param \'$param$\' not found in command line template.\n"; 
	}
    }
}


sub output_dir_default_name{
    die if @_ != 0; 
    my $output_dir = date_string().'/';

    $output_dir =~ s/ /_/g; 
    $output_dir =~ s/://g;

    return $output_dir; 
}

sub get_process_table{
    die if @_ != 0; 
     return new Proc::ProcessTable;
}

sub kill_process_tree{
    die if @_ != 1; 
    my ($pid) = @_;
    my $t = get_process_table;
    
    foreach my $p (@{$t->table}) {
	if($p->{"ppid"} == $pid){
	    kill_process_tree($p->{"pid"}); 
	}
	# if($p->{"pid"} == $pid){
	#     print "Killing".$p->{"cmndline"}."\n"; 
	# }
    }
    kill 9, $pid; 
}

sub init{
    die if @_ != 0; 

# memory 
    $total_memory = get_total_memory(); 

# initialize timer for the control loop
    $SIG {ALRM} = sub {
	$current_time+=$CYCLE_LEN; 
	my $mu = check_memory_usage();
	my $tu = check_timeout(); 
	if($mu or $tu){
	    print STDERR "killing $current_process_name.\n";
	    kill_process_tree($current_process_pid);
	    if($mu){
		$current_process_err = "ERR_MEM"; 
	    }
	    else{
		$current_process_err = "ERR_TME"; 
	    }

	    sleep(1); 
	}
	else {
	    alarm $CYCLE_LEN;
	}
    };

    $output_dir = output_dir_default_name(); 
    
}

# records a new parameter and its possible values
sub add_parameter_values{
     die if @_ != 2; 
     my ($p_name, $value_space_ref) =  @_; 
     $parameter_values{$p_name} = $value_space_ref; 
     Using::add_parameter_range($p_name, $#{$value_space_ref}+1); 
}


sub create_readme_file{
    die if @_ < 1; 
    my @argv = @_;
    open README, ">$output_dir/README.tmp" or die $!;

    print README "\n###########################\n";
    print README "Experiment started at $START_TIME on ".get_hostname().".\n";
    print README "$0 ".join(' ',@argv)."\n";
    close README; 
 }

sub finalize_readme_file{
    die if @_ != 0;
    open README, ">>$output_dir/README" or die $!;
    open READMETMP, "$output_dir/README.tmp" or die $!;
    print README "\n\n"; 
    foreach my $cl (@progtotest_command_lines){
	print README "$cl\n"; 
    }    
    print README "\n"; 

    while (my $line = <READMETMP>){
	print README $line; 
    }
    close READMETMP;
    print README "Expeperiment finished at ".date_string."\n";
    close README;
    system ("rm -f $output_dir/README.tmp"); 
    
}

sub populate_output_dir{
    die if @_ != 1; 
    my ($output_dir) = @_;

    system("mkdir -p $output_dir/"); 
    system("mkdir -p $output_dir/time"); 
    system("mkdir -p $output_dir/mem"); 
    system("mkdir -p $output_dir/output");
    system("mkdir -p $output_dir/usr") if $post_exec_script_path; 
}

sub parse_program_arguments{
    $#_ == 0 or die "Unexpected argument number.\n"; 
    my @argv = @{$_[0]}; 

    while (my $arg = shift @argv){
	if($arg =~ /\-([putmso-])/){

	    ####################
	    #### parameters ####
	    ####################
	    if($1 eq 'p'){
		# parse a param argument
		# creates a param entry with a list of values for this param
		if(defined(my $p_name = shift @argv)){
		    if(not $p_name =~ /[a-zA-Z_][a-zA-Z_0-9]*/){
			error_args "Parameter '$p_name' is not a valid parameter name (parameter names must match [a-zA-Z_][a-zA-Z_0-9]*.";
		    }
		    
		    my @values = (); 
		    while(defined (my $n = shift @argv)){
			if($n =~ /^-/){
			    unshift @argv, $n; 
			    last; 
			}
			push @values, $n; 
		    }
		    if(@values != 0){
			declare_parameter($p_name, @values); 
		    }
		    else{
			error_args "No value provided for parameter '$p_name'.";
		    }
		}
		else{
		    print_usage(); 
		}
	    }

	    ###############
	    #### using ####
	    ###############
	    elsif($1 eq 'u'){
		if(defined(my $param = shift @argv)){
		    foreach my $param_name (keys %params){
			declare_parameter($param_name, $params{$param_name}); 
		    }

		    $using_ast = Using::parse($param);
		}
		else{
		    print_usage();
		}
	    }

	    #################
	    #### timeout ####
	    #################	    
	    elsif($1 eq 't'){
		if(defined(my $param = shift @argv)){
		    $timeout = $param; 
		    if($timeout <= $CYCLE_LEN){
			print STDERR "Warning: timout value ($timeout sec) is below timeout resolution ($CYCLE_LEN sec).\n"; }
		}
		else{
		    print_usage; 
		}
	    }

	    ######################
	    #### memory limit ####
	    ######################	    
	    elsif($1 eq 'm'){
		if(defined(my $param = shift @argv)){
		    $mem_usage_cap = $param * $total_memory / 100; 
		}
		else{
		    print_usage; 
		}
	    }


	    ##########################
	    #### post exec script ####
	    ##########################	    
	    elsif($1 eq 's'){
		if(defined(my $param = shift @argv)){
		    $post_exec_script_path = $param;

		}
		else{
		    print_usage; 
		}
	    }

	    #################################
	    #### use existing output dir ####
	    #################################	    
	    elsif($1 eq 'o'){
		if(defined(my $param = shift @argv)){
		    $output_dir = $param.'/';
		}
		else{
		    print_usage;
		}
	    }
	    
	    elsif($1 eq '-'){
		if(@argv == 0) {print_usage; die "Cannot parse command line\n";}
		
		$progtotest_command_template = join(' ',@argv);
		@argv=(); 
	    }
	    else{
		print_usage;
		die; 
	    }

	}
    }
}


# Build a command line from the command line template and a tuple of
# value references.
#
# Iterate through the template and replace occurrences of PNAME with
# value refered by the first value reference <PNAME, value_index>.
# Warning: If the same PNAME occurs multiple times, each occurrence is
# only replaced once for each value reference (left-most occurrences
# are replaced first.)
sub build_a_command_line{
    die if @_ != 2; 
    my $template = $_[0];
    my @tuple = @{$_[1]}; 

    foreach my $vr(@tuple){
	my $pname = value_ref_get_pname($vr);
	my $value = value_ref_get_value($vr);

	if(not ($template =~ s/$pname/$value/)){
	    warning_build_command_line
		"Parameter '$pname' not found in command line template."; 
	}
    }
    return $template;     
}


# Build a dimension name from a tuple and a dimension specification
# (i.e. f c or l).  
#
# e.g. tuple_build_dim_name([ <A:1> <B:2> <C:1> <D:2> ], 'l') will
# return the string "C.1_D.2" if the dimension specification is "fcll" 
# (file column line line)
sub tuple_build_dim_name{
    die if @_ != 2; 
    my ($tuple, $dim_name) = @_;
    my $string = "";
    my @dims_index = ast_get_dimension_indexes($using_ast, $dim_name);

    my $i = 0; 
    foreach my $vr_index(@dims_index){
	$string .= value_ref_get_pname($tuple->[$vr_index]).".".value_ref_get_value($tuple->[$vr_index]);
	if(++$i != @dims_index){
	    $string .= '_';     
	}
    }
    return $string; 
}


# Convert a tuple into a filename
sub tuple_to_filename{
    die if @_ != 1; 
    my ($tuple) = @_;
    my $string = "";
    my @file_dims = ast_get_dimension_indexes($using_ast, "f");
    my @cols_dims = ast_get_dimension_indexes($using_ast, "c");
    my @line_dims = ast_get_dimension_indexes($using_ast, "l"); 
    my $total = @file_dims + @cols_dims + @line_dims; 

    my $i = 0; 

    foreach my $d (@file_dims){
	my $vr = $tuple->[$d]; 
	$string .= value_ref_get_pname($vr);
	$string .= '.'.value_ref_get_value($vr);
	if(++$i != $total){
	    $string .= '_';
	}
    }
    foreach my $d (@cols_dims){
	my $vr = $tuple->[$d]; 
	$string .= value_ref_get_pname($vr);
	if(++$i != $total){
	    $string .= '_';
	}
    }
    foreach my $d (@line_dims){
	my $vr = $tuple->[$d]; 
	$string .= value_ref_get_pname($vr);
	if(++$i != $total){
	    $string .= '_';
	}
    }
    return $string; 
}

# Store a result in a structed db. 
sub store_result{
    die if @_ != 3;
    my ($tag, $tuple, $result_string) = @_; 

    result_db_insert_value(tuple_to_filename($tuple), tuple_build_dim_name($tuple, 'c'),
			   tuple_build_dim_name($tuple, 'l'), $result_string);
}

# Given a list of tuples and a tuple, return all the tuple that are
# the in same equivalent class with respect to the format
# specification two tuples are in the same class if all their
# parameters of this class have the same value.
sub get_tuple_equivalence_class{
    die if @_ != 3;
    my ($tuples, $tuple, $format_spec) = @_;
    my @all_param_names = all_parameter_names_in_std_order();
    my @class_params = (); 
    
    for(my $i = 0; $i < @all_param_names; $i++){
	if(parameter_get_format_spec($all_param_names[$i]) 
	   eq $format_spec){
	    push @class_params, $i; 
	}
    }

    my @class = (); 
    foreach my $t (@{$tuples}){
	my $same_class = 1;
	foreach my $c (@class_params){
	    if(not (value_ref_get_value($t->[$c]) eq 
		    value_ref_get_value($tuple->[$c]))){
		$same_class = 0; 
	    }
	}
	push @class, $t;
    }
    return @class; 
}

# builds an array containing a class specification for each class of
# level f, c or l.
sub build_class_spec{
    die if @_ != 3;
    my ($tuples, $tuple, $format_spec) = @_;
    my @all_param_names = all_parameter_names_in_std_order();
    my @class_params = (); 
    
    for(my $i = 0; $i < @all_param_names; $i++){
	if(parameter_get_format_spec($all_param_names[$i]) 
	   eq $format_spec){
	    push @class_params, $i; 
	}
    }

    my @class = (); 

    
}

# Returns a class specification from a tuple. A class specification is
# also a tuple in which only class relevant parameters their
# values are preserved. A tuple belongs to a class if all the values
# that occurs in the class spec match the values in the tuple.
#
# For example [ <:> <B:2> <:> ] is a possible class spec and the tuples:
#  [ <A:1> <B:2> <C:3> ] and [ <A:3> <B:2> <C:17> ] both belong to the
#  class defined by the class spec.
#
# There are three types of class, one f (for file) class type for the
#  class of tuples refers values that have to be stored in the same
#  file, one c class type (for column) and one l class type for
#  (line).
# 
sub tuple_to_class_spec{
    die if @_ != 2;
    my ($tuple, $class_type) = @_;  

    my @class_spec = (); 
    foreach my $vr (@$tuple){
	if(parameter_get_format_spec(value_ref_get_pname($vr)) 
	   eq $class_type){
	    push @class_spec, $vr; 
	}
	else{
	    push @class_spec, ["",""];
	}
    }

    return \@class_spec; 
}

# Given a set of tuples and a class spec (see tuple_to_class_spec),
# returns all the tuples that belong to the class described by class
# spec.
sub get_class_from_class_spec{
    die if @_ != 2; 
    my ($all_tuples, $class_spec) = @_;
    my @class = (); 
    
    foreach my $t (@$all_tuples){
	my $same_class_flag = 1; 
	for(my $i = 0; $i < @$t; $i++){
	    if(value_ref_get_pname($class_spec->[$i]) ne ""){
		if(value_ref_get_value($class_spec->[$i]) ne 
			value_ref_get_value($t->[$i])){
		    $same_class_flag = 0;
		    last; 
		}
	    }
	}
	if($same_class_flag == 1){
	    push @class, $t ; 
	}
    }

    return @class; 
}


# A class is a set of tuples that have the same value on a set of
# parameter.  class type is either f c l, if class_type is f, the
# function will return all the tuples that belong to the same file.
# i.e. that have the same value on all the parameter with a f format
# string.
sub get_all_classes_from_class_type{
    die if @_ != 2; 
    my ($all_tuples, $class_type) = @_; 
    
    my @all_classes = ();
    my %class_index = (); # to compute class indexes
    
    foreach my $t (@$all_tuples){
	my @class_spec = @{tuple_to_class_spec($t, $class_type)}; 
	my $class_spec_string = tuple_to_string(\@class_spec);

	my $i = $class_index{$class_spec_string};
	if(not defined $i){
	    # first instance of the class, attribute an index.
	    $i = @all_classes; 
	    $class_index{$class_spec_string} = $i;
	    $all_classes[$i] = []; 
	}
	push @{$all_classes[$i]}, $t; 
    }
    return \@all_classes; 
}


# Given a tuple (usually, the first of a line class of tuples), write
# the line heading for the corresponding class.
# The heading is the values of all the parameters that
# remain constant among all the line. (Usually one.)
sub write_line_head_from_tuple{
    die if @_ != 2; 
    my ($tuple, $fh) = @_;

    my @l_values = get_value_refs_from_format_spec($tuple, 'l');

    foreach my $j (0..$#l_values){
	my $vr = $l_values[$j]; 
	print {$fh} value_ref_get_value($vr);
	print {$fh} $CELL_RESULT_SEPARATOR if($j < $#l_values)
    }
    print {$fh} $COLUMN_RESULT_SEPARATOR; 
}

# Bad code duplication of write_line_head_from_tuple. 
# The only thing that differ is the head formating. 
sub write_column_head_from_tuple{
    die if @_ != 2; 
    my ($tuple, $fh) = @_;

    my @c_values = get_value_refs_from_format_spec($tuple, 'c');

    foreach my $j (0..$#c_values){
	my $vr = $c_values[$j]; 
	print $fh value_ref_get_pname($vr).'='.value_ref_get_value($vr);  
	print {$fh} $CELL_RESULT_SEPARATOR if($j < $#c_values)
    }
    print {$fh} $COLUMN_RESULT_SEPARATOR; 
}

# Given a tuple, and a format spec (f, c or l) returns all the value
# refs that match the format spec
sub get_value_refs_from_format_spec{
    die if @_ != 2; 
    my ($tuple, $format_spec) = @_;

    my @vrefs = (); 
    foreach my $vr (@$tuple){
	my $pname = value_ref_get_pname($vr); 
	if(parameter_get_format_spec($pname) eq $format_spec){
	    push @vrefs, $vr; 
	}
    }
    return @vrefs; 
}

# Given a list of tuples that belong to the same file, print the values as lines
# and columns according to the format specified by the using
# expression.  $fh is a file handle to the file in which we want to
# print.
# Waring: all the tuples must belong to the same file.
sub write_a_result_file{
    die if @_ != 4; 
    my ($result_db, $file_class_tuples, $file_prefix, $info_reported) = @_;

    my $filename = $file_prefix.tuple_to_filename($file_class_tuples->[0]);
    my $fh; 
    if(not (open $fh, ">$filename")){
	warning_output("Cannot create result file '$filename': $! Using stdout."); 
	$fh = \*STDOUT; 
    }

    print_file_header($fh, "/bin/ls", $info_reported);
    
    print $fh '# ';
    # print first column header ie. column parameters names 
    my @l_vr = get_value_refs_from_format_spec($file_class_tuples->[0], 'l');
    foreach my $i (0..$#l_vr){
	print $fh value_ref_get_pname($l_vr[$i]);
	print $fh $CELL_RESULT_SEPARATOR if($i < $#l_vr); 
    }
    print $fh $COLUMN_RESULT_SEPARATOR; 
    
    # print columns headers
    my $all_c_classes = get_all_classes_from_class_type($file_class_tuples, 'c'); 
    foreach my $c_class (@$all_c_classes){
	my $tuple = $c_class->[0];
	write_column_head_from_tuple($tuple, $fh);
    }
    print $fh $LINE_RESULT_SEPARATOR; 

    # print line headers and values
    my $all_l_classes = get_all_classes_from_class_type($file_class_tuples, 'l'); 
    foreach my $l_class (@$all_l_classes){
	write_line_head_from_tuple($l_class->[0], $fh);
	my $all_c_classes = get_all_classes_from_class_type($l_class, 'c'); 
	foreach my $c_class (@$all_c_classes){
	    foreach my $v (@$c_class){
		print $fh $result_db->get_result($v);
	    }
	    print $fh $COLUMN_RESULT_SEPARATOR; 
	}
	print $fh $LINE_RESULT_SEPARATOR; 
    }
    close $fh; 
}

sub write_result_files{
    die if @_ != 4; 
    my ($tuples, $result_db, $file_prefix, $info_reported) = @_; 
    if($result_db->is_dirty()){    
	my $all_file_classes = get_all_classes_from_class_type($tuples, 'f'); 
	foreach my $f_class (@$all_file_classes){
	write_a_result_file($result_db, $f_class, $file_prefix, $info_reported); 
	}
    }
}

sub startup{
    my @argv = @_; 
    init(); 
    parse_program_arguments(\@argv);
    #print ast_to_string($using_ast);
    check_ast($using_ast);
    #print ast_to_string($using_ast);
    populate_output_dir($output_dir);

# Creating the databases    
    my $time_db = new Result_Db($output_dir, "time");
    my $mem_db = new Result_Db($output_dir, "mem");
    my $usr_db; 
    if($post_exec_script_path){
	$usr_db = new Result_Db($output_dir, "usr");}

# Fetching the tuples and preparing the databses
    my @tuples = @{ast_get_tuples($using_ast)};
    foreach my $t (@tuples){
	$time_db->result_db_add_tuple($t);
	$mem_db->result_db_add_tuple($t);
	if($post_exec_script_path){
	    $usr_db->result_db_add_tuple($t);
	}
    }

# Misc
    print_info();
    create_readme_file(@argv); 

# Everything seems to be OK. Starting experiments.
    print "\nEverything seems to be OK. Starting experiments.\n\n";
    
    foreach my $t (@tuples){
	my $cl = build_a_command_line($progtotest_command_template, $t);
	push @progtotest_command_lines, $cl;
	my ($time, $mem, $usr) =  run_child($cl);
	$time_db->result_db_set_result($t, $time);
	$mem_db->result_db_set_result($t, $mem);
	$usr_db->result_db_set_result($t, $usr) if($post_exec_script_path);
	
	# writing results... after each run for more safety. 
	write_result_files(\@tuples, $time_db,
			   $output_dir.'time/time_', "Wall clock time (in seconds)");
	write_result_files(\@tuples, $mem_db,
			   $output_dir.'mem/mem_', "Max memory usage (in MiB)");
	if($post_exec_script_path){
	    write_result_files(\@tuples, $usr_db,
			       $output_dir.'usr/usr_',
			       "User script output");
	}
    }

# Finalize
    finalize_readme_file(); 

}

1;
__END__
# Below is stub documentation for your module. You'd better edit it!

=head1 NAME

runtime - Perl extension for blah blah blah

=head1 SYNOPSIS

  use runtime;
  blah blah blah

=head1 DESCRIPTION

Runtime can be used to measure and plot statistics such as time or
memory usage on programs with a (possibly large) number of parameters.

For example the following command:

 $> runtime -p P1 a1 a2 -p P2 b1 b2 b3 -u P1cxP2l -- echo P1 P2

will 
1. Run the following commands 

echo a1 b1
echo a1 b2
echo a1 b3
echo a2 b1
echo a2 b2
echo a2 b3

2. Collect time statistics and store them into file. 
One value per column for P1, one value per line for P2.


Essentially Runtime is a tool to map points in a high dimensional
space (the space of parameters) onto the three dimensional space that
consists in columns, lines, and files.





Stub documentation for runtime, created by h2xs. It looks like the
author of the extension was negligent enough to leave the stub
unedited.

Blah blah blah.

=head2 EXPORT

None by default.



=head1 SEE ALSO

Mention other useful documentation such as the documentation of
related modules or operating system documentation (such as man pages
in UNIX), or any relevant external documentation such as RFCs or
standards.

If you have a mailing list set up for your module, mention it here.

If you have a web site set up for your module, mention it here.

=head1 AUTHOR

Benjamin Negrevergne, E<lt>benjamin@E<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013 by Benjamin Negrevergne

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.14.2 or,
at your option, any later version of Perl 5 you may have available.


=cut








